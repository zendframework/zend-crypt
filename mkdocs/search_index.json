{
    "docs": [
        {
            "location": "/", 
            "text": "zend-crypt\n\n\n\n\n\n\nZend\\Crypt\n provides support of some cryptographic tools.\nThe available features are:\n\n\n\n\nencrypt-then-authenticate using symmetric ciphers (the authentication step\n  is provided using HMAC);\n\n\nencrypt/decrypt using symmetric and public key algorithm (e.g. RSA algorithm);\n\n\ngenerate digital sign using public key algorithm (e.g. RSA algorithm);\n\n\nkey exchange using the Diffie-Hellman method;\n\n\nkey derivation function (e.g. using PBKDF2 algorithm);\n\n\nsecure password hash (e.g. using Bcrypt algorithm);\n\n\ngenerate Hash values;\n\n\ngenerate HMAC values;\n\n\n\n\nThe main scope of this component is to offer an easy and secure way to protect\nand authenticate sensitive data in PHP.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-crypt/issues\n\n\nDocumentation is at http://framework.zend.com/manual/current/en/index.html#zend-crypt", 
            "title": "Home"
        }, 
        {
            "location": "/#zend-crypt", 
            "text": "Zend\\Crypt  provides support of some cryptographic tools.\nThe available features are:   encrypt-then-authenticate using symmetric ciphers (the authentication step\n  is provided using HMAC);  encrypt/decrypt using symmetric and public key algorithm (e.g. RSA algorithm);  generate digital sign using public key algorithm (e.g. RSA algorithm);  key exchange using the Diffie-Hellman method;  key derivation function (e.g. using PBKDF2 algorithm);  secure password hash (e.g. using Bcrypt algorithm);  generate Hash values;  generate HMAC values;   The main scope of this component is to offer an easy and secure way to protect\nand authenticate sensitive data in PHP.   File issues at https://github.com/zendframework/zend-crypt/issues  Documentation is at http://framework.zend.com/manual/current/en/index.html#zend-crypt", 
            "title": "zend-crypt"
        }, 
        {
            "location": "/intro/", 
            "text": "Introduction\n\n\nzend-crypt provides support for several cryptographic tools, with the following\nfeatures:\n\n\n\n\nencrypt-then-authenticate using symmetric ciphers (the authentication step is\n  provided using HMAC);\n\n\nencrypt/decrypt using symmetric and public key algorithm (e.g. RSA algorithm);\n\n\ngenerate digital signature using public key algorithm (e.g. RSA algorithm);\n\n\nkey exchange using the Diffie-Hellman method;\n\n\nkey derivation function (e.g. using PBKDF2 algorithm);\n\n\nsecure password hash (e.g. using bcrypt algorithm);\n\n\ngenerate hash values; and\n\n\ngenerate HMAC values.\n\n\n\n\nThe main scope of this component is to offer an easy and secure way to protect\nand authenticate sensitive data in PHP. Because the use of cryptography is often\ncomplex, we recommend using the component only if you have background on this\ntopic. For an introduction to cryptography, we suggest the following references:\n\n\n\n\nDan Boneh, \n\"Cryptography course\"\n,\n  Stanford University, Coursera; free online course\n\n\nN.Ferguson, B.Schneier, and T.Kohno, \n\"Cryptography Engineering\"\n,\n  John Wiley \n Sons (2010)\n\n\nB.Schneier \n\"Applied Cryptography\"\n,\n  John Wiley \n Sons (1996)", 
            "title": "Intro"
        }, 
        {
            "location": "/intro/#introduction", 
            "text": "zend-crypt provides support for several cryptographic tools, with the following\nfeatures:   encrypt-then-authenticate using symmetric ciphers (the authentication step is\n  provided using HMAC);  encrypt/decrypt using symmetric and public key algorithm (e.g. RSA algorithm);  generate digital signature using public key algorithm (e.g. RSA algorithm);  key exchange using the Diffie-Hellman method;  key derivation function (e.g. using PBKDF2 algorithm);  secure password hash (e.g. using bcrypt algorithm);  generate hash values; and  generate HMAC values.   The main scope of this component is to offer an easy and secure way to protect\nand authenticate sensitive data in PHP. Because the use of cryptography is often\ncomplex, we recommend using the component only if you have background on this\ntopic. For an introduction to cryptography, we suggest the following references:   Dan Boneh,  \"Cryptography course\" ,\n  Stanford University, Coursera; free online course  N.Ferguson, B.Schneier, and T.Kohno,  \"Cryptography Engineering\" ,\n  John Wiley   Sons (2010)  B.Schneier  \"Applied Cryptography\" ,\n  John Wiley   Sons (1996)", 
            "title": "Introduction"
        }, 
        {
            "location": "/block-cipher/", 
            "text": "Encrypt/decrypt using block ciphers\n\n\nZend\\Crypt\\BlockCipher\n implements encrypt-then-authenticate mode using\n\nHMAC\n to provide authentication.\n\n\nThe symmetric cipher can be chosen with a specific adapter that implements\n\nZend\\Crypt\\Symmetric\\SymmetricInterface\n. We support the symmmetric encryption\nalgorithms offered by \nOpenSSL\n and\n\nMcrypt\n extensions.\n\n\nIn the following code, we detail an example of using the \nBlockCipher\n class to\nencrypt-then-authenticate a string using the\n\nAES-256\n block cipher\nand the HMAC algorithm (using the \nSHA-256\n\nhash function).\n\n\n\n\nMcrypt\n\n\nThe Mcrypt extension is based on the libmcrypt library. Unfortunately, at the\ntime of writing, the project is dead, having been unmaintained for around 8\nyears, with the last release (version 2.5.8) having occurred in February 2007.\n\n\nStarting with PHP 7.1, the Mcrypt extension will be\n\nconsidered deprecated\n.\nFor these reasons, \nwe strongly suggest using only the Openssl adapter\n.\n\n\nStarting with zend-crypt 3.0, the Openssl adapter is the default (for example,\nby \nZend\\Crypt\\FileCipher\n), and all examples now only demonstrate that\nadapter.\n\n\n\n\nuse Zend\\Crypt\\BlockCipher;\n\n$blockCipher = BlockCipher::factory('openssl', array('algo' =\n 'aes'));\n$blockCipher-\nsetKey('encryption key');\n$result = $blockCipher-\nencrypt('this is a secret message');\necho \nEncrypted text: $result\\n\n;\n\n\n\n\nThe \nBlockCipher\n instance is initialized using a factory method with the name\nof the cipher adapter to use (e.g., \nopenssl\n) and the parameters to pass to the adapter\n(the AES algorithm). In order to encrypt a string, we need to specify an\nencryption key, which we do via the \nsetKey()\n method. Encryption is performed\nwith the \nencrypt()\n method.\n\n\nThe output of encryption is a string, encoded in Base64 (default), containing\nthe HMAC value, the IV vector, and the encrypted text. The encryption mode used\nis \nCBC\n\n(with a random \nIV\n by\ndefault), with the default HMAC hash algorithm of SHA256.  The Openssl adapter\nencrypts using the \nPKCS#7 padding\n\nmechanism by default. You can specify a different padding method using a special\nadapter (\nZend\\Crypt\\Symmetric\\Padding\n). The encryption and authentication keys\nused by \nBlockCipher\n are generated with the \nPBKDF2\n\nalgorithm, used as the key derivation function from the user's key specified\nusing the \nsetKey()\n method.\n\n\n\n\nKey size\n\n\nBlockCipher always attempts to use the longest key size for the specified\ncipher. For instance, for the AES algorithm it uses 256 bits, and for the\n\nBlowfish\n algorithm it\nuses 448 bits.\n\n\n\n\nYou can change all the default settings by passing the values to the factory\nparameters. For instance, if you want to use the Blowfish algorithm, with the\nCFB mode and the HMAC SHA512 hash function, initialize the class as follows:\n\n\nuse Zend\\Crypt\\BlockCipher;\n\n$blockCipher = BlockCipher::factory(\n    'openssl',\n    [\n        'algo' =\n 'blowfish',\n        'mode' =\n 'cfb',\n        'hash' =\n 'sha512'\n    ]\n);\n\n\n\n\n\n\nRecommendation\n\n\nIf you are not familiar with symmetric encryption techniques, we strongly\nsuggest using the default values of the \nBlockCipher\n class. The default\nvalues are: AES algorithm, CBC mode, HMAC with SHA256, PKCS#7 padding.\n\n\n\n\nTo decrypt a string we can use the \ndecrypt()\n method. In order to successfully\ndecrypt a string, we must configure the \nBlockCipher\n with the same parameters\nused during encryption.\n\n\nWe can also initialize the \nBlockCipher\n manually without using the factory method;\nwe can inject the symmetric cipher adapter directly via the constructor.\nFor instance, we can rewrite the previous example as follows:\n\n\nuse Zend\\Crypt\\BlockCipher;\nuse Zend\\Crypt\\Symmetric\\Mcrypt;\n\n$blockCipher = new BlockCipher(new Mcrypt(['algo' =\n 'aes']));\n$blockCipher-\nsetKey('encryption key');\n$result = $blockCipher-\nencrypt('this is a secret message');\necho \nEncrypted text: $result \\n\n;", 
            "title": "Block Ciphers"
        }, 
        {
            "location": "/block-cipher/#encryptdecrypt-using-block-ciphers", 
            "text": "Zend\\Crypt\\BlockCipher  implements encrypt-then-authenticate mode using HMAC  to provide authentication.  The symmetric cipher can be chosen with a specific adapter that implements Zend\\Crypt\\Symmetric\\SymmetricInterface . We support the symmmetric encryption\nalgorithms offered by  OpenSSL  and Mcrypt  extensions.  In the following code, we detail an example of using the  BlockCipher  class to\nencrypt-then-authenticate a string using the AES-256  block cipher\nand the HMAC algorithm (using the  SHA-256 \nhash function).", 
            "title": "Encrypt/decrypt using block ciphers"
        }, 
        {
            "location": "/block-cipher/#mcrypt", 
            "text": "The Mcrypt extension is based on the libmcrypt library. Unfortunately, at the\ntime of writing, the project is dead, having been unmaintained for around 8\nyears, with the last release (version 2.5.8) having occurred in February 2007.  Starting with PHP 7.1, the Mcrypt extension will be considered deprecated .\nFor these reasons,  we strongly suggest using only the Openssl adapter .  Starting with zend-crypt 3.0, the Openssl adapter is the default (for example,\nby  Zend\\Crypt\\FileCipher ), and all examples now only demonstrate that\nadapter.   use Zend\\Crypt\\BlockCipher;\n\n$blockCipher = BlockCipher::factory('openssl', array('algo' =  'aes'));\n$blockCipher- setKey('encryption key');\n$result = $blockCipher- encrypt('this is a secret message');\necho  Encrypted text: $result\\n ;  The  BlockCipher  instance is initialized using a factory method with the name\nof the cipher adapter to use (e.g.,  openssl ) and the parameters to pass to the adapter\n(the AES algorithm). In order to encrypt a string, we need to specify an\nencryption key, which we do via the  setKey()  method. Encryption is performed\nwith the  encrypt()  method.  The output of encryption is a string, encoded in Base64 (default), containing\nthe HMAC value, the IV vector, and the encrypted text. The encryption mode used\nis  CBC \n(with a random  IV  by\ndefault), with the default HMAC hash algorithm of SHA256.  The Openssl adapter\nencrypts using the  PKCS#7 padding \nmechanism by default. You can specify a different padding method using a special\nadapter ( Zend\\Crypt\\Symmetric\\Padding ). The encryption and authentication keys\nused by  BlockCipher  are generated with the  PBKDF2 \nalgorithm, used as the key derivation function from the user's key specified\nusing the  setKey()  method.", 
            "title": "Mcrypt"
        }, 
        {
            "location": "/block-cipher/#key-size", 
            "text": "BlockCipher always attempts to use the longest key size for the specified\ncipher. For instance, for the AES algorithm it uses 256 bits, and for the Blowfish  algorithm it\nuses 448 bits.   You can change all the default settings by passing the values to the factory\nparameters. For instance, if you want to use the Blowfish algorithm, with the\nCFB mode and the HMAC SHA512 hash function, initialize the class as follows:  use Zend\\Crypt\\BlockCipher;\n\n$blockCipher = BlockCipher::factory(\n    'openssl',\n    [\n        'algo' =  'blowfish',\n        'mode' =  'cfb',\n        'hash' =  'sha512'\n    ]\n);", 
            "title": "Key size"
        }, 
        {
            "location": "/block-cipher/#recommendation", 
            "text": "If you are not familiar with symmetric encryption techniques, we strongly\nsuggest using the default values of the  BlockCipher  class. The default\nvalues are: AES algorithm, CBC mode, HMAC with SHA256, PKCS#7 padding.   To decrypt a string we can use the  decrypt()  method. In order to successfully\ndecrypt a string, we must configure the  BlockCipher  with the same parameters\nused during encryption.  We can also initialize the  BlockCipher  manually without using the factory method;\nwe can inject the symmetric cipher adapter directly via the constructor.\nFor instance, we can rewrite the previous example as follows:  use Zend\\Crypt\\BlockCipher;\nuse Zend\\Crypt\\Symmetric\\Mcrypt;\n\n$blockCipher = new BlockCipher(new Mcrypt(['algo' =  'aes']));\n$blockCipher- setKey('encryption key');\n$result = $blockCipher- encrypt('this is a secret message');\necho  Encrypted text: $result \\n ;", 
            "title": "Recommendation"
        }, 
        {
            "location": "/files/", 
            "text": "Encrypt and decrypt files\n\n\nZend\\Crypt\\FileCipher\n implements file encryption and decryption using a\nsymmetric cipher in\n\nCBC\n\nmode with the encrypt-then-authenticate approach, using\n\nHMAC\n to provide authentication (the same\nsolution used by \nZend\\Crypt\\BlockCipher\n component).\n\n\nEncrypting and decrypting a file is not an easy task, especially with large\nfiles. For instance, in CBC mode you must be sure to handle the\n\nIV\n correctly for each\nblock. For large files, that means that you need to use a buffer and use the\nlast block of the buffer as the new IV for the next encryption step.\n\n\nFileCipher\n uses a \nZend\\Crypt\\Symmetric\n cipher to encrypt and decrypt a file.\nThe default cipher is \nZend\\Crypt\\Symmetric\\Openssl\n.\n\n\nThe usage of this component is very simple; create an instance of \nFileCipher\n,\nspecify the key, and you are ready to encrypt/decrypt any file:\n\n\nuse Zend\\Crypt\\FileCipher;\n\n$fileCipher = new FileCipher;\n$fileCipher-\nsetKey('encryption key');\n\n// encryption\nif ($fileCipher-\nencrypt('path/to/file_to_encrypt', 'path/to/output')) {\n    echo \nThe file has been encrypted successfully\\n\n;\n}\n\n// decryption\nif ($fileCipher-\ndecrypt('path/to/file_to_decrypt', 'path/to/output')) {\n    echo \nThe file has been decrypted successfully\\n\n;\n}\n\n\n\n\nBy default, \nFileCipher\n uses the \nAES\n\nencryption algorithm (with a 256-bit key) and the \nSHA-256\n\nhash algorithm to authenticate the data using the HMAC function. This component uses the\n\nPBKDF2\n key derivation algorithm to generate the encryption\nkey and the authentication key, for the HMAC, based on the key specified using the method\n\nsetKey()\n.\n\n\nIf you want to change the encryption algorithm, you can use the \nsetCipherAlgorithm()\n function. For\ninstance, you could specify the \nBlowfish\n\nencryption algorithm using \nsetCipherAlgorithm('blowfish')\n. You can retrieve the list of all\nsupported encryption algorithms in your environment using the function\n\ngetCipherSupportedAlgorithms()\n.\n\n\nIf you need to customize the cipher algorithm \n for instance, to change\nthe Padding mode \n you can inject your \nMcrypt\n object in the \nFileCipher\n\nusing the \nsetCipher()\n method. The only parameter of the cipher that you cannot\nchange is the cipher mode, which is hard-coded to CBC.\n\n\n\n\nOutput format\n\n\nThe output of the encryption file is in binary format. We used this format to\nreduce impact on output size. If you encrypt a file using the \nFileCipher\n\ncomponent, you will notice that the output file size is almost the same as the\ninput size, with a few additional bytes to store the HMAC and the IV vector.\nThe format of the output is the concatenation of the HMAC, the IV, and the\nencrypted file contents.", 
            "title": "Encrypting Files"
        }, 
        {
            "location": "/files/#encrypt-and-decrypt-files", 
            "text": "Zend\\Crypt\\FileCipher  implements file encryption and decryption using a\nsymmetric cipher in CBC \nmode with the encrypt-then-authenticate approach, using HMAC  to provide authentication (the same\nsolution used by  Zend\\Crypt\\BlockCipher  component).  Encrypting and decrypting a file is not an easy task, especially with large\nfiles. For instance, in CBC mode you must be sure to handle the IV  correctly for each\nblock. For large files, that means that you need to use a buffer and use the\nlast block of the buffer as the new IV for the next encryption step.  FileCipher  uses a  Zend\\Crypt\\Symmetric  cipher to encrypt and decrypt a file.\nThe default cipher is  Zend\\Crypt\\Symmetric\\Openssl .  The usage of this component is very simple; create an instance of  FileCipher ,\nspecify the key, and you are ready to encrypt/decrypt any file:  use Zend\\Crypt\\FileCipher;\n\n$fileCipher = new FileCipher;\n$fileCipher- setKey('encryption key');\n\n// encryption\nif ($fileCipher- encrypt('path/to/file_to_encrypt', 'path/to/output')) {\n    echo  The file has been encrypted successfully\\n ;\n}\n\n// decryption\nif ($fileCipher- decrypt('path/to/file_to_decrypt', 'path/to/output')) {\n    echo  The file has been decrypted successfully\\n ;\n}  By default,  FileCipher  uses the  AES \nencryption algorithm (with a 256-bit key) and the  SHA-256 \nhash algorithm to authenticate the data using the HMAC function. This component uses the PBKDF2  key derivation algorithm to generate the encryption\nkey and the authentication key, for the HMAC, based on the key specified using the method setKey() .  If you want to change the encryption algorithm, you can use the  setCipherAlgorithm()  function. For\ninstance, you could specify the  Blowfish \nencryption algorithm using  setCipherAlgorithm('blowfish') . You can retrieve the list of all\nsupported encryption algorithms in your environment using the function getCipherSupportedAlgorithms() .  If you need to customize the cipher algorithm   for instance, to change\nthe Padding mode   you can inject your  Mcrypt  object in the  FileCipher \nusing the  setCipher()  method. The only parameter of the cipher that you cannot\nchange is the cipher mode, which is hard-coded to CBC.", 
            "title": "Encrypt and decrypt files"
        }, 
        {
            "location": "/files/#output-format", 
            "text": "The output of the encryption file is in binary format. We used this format to\nreduce impact on output size. If you encrypt a file using the  FileCipher \ncomponent, you will notice that the output file size is almost the same as the\ninput size, with a few additional bytes to store the HMAC and the IV vector.\nThe format of the output is the concatenation of the HMAC, the IV, and the\nencrypted file contents.", 
            "title": "Output format"
        }, 
        {
            "location": "/key-derivation/", 
            "text": "Key derivation function\n\n\nIn cryptography, a key derivation function (or KDF) derives one or more secret\nkeys from a secret value such as a master key, or known information \n such\nas a password or passphrase \n using a pseudo-random function. For\ninstance, a KDF function can be used to generate encryption or authentication\nkeys from a user password. \nZend\\Crypt\\Key\\Derivation\n implements a key\nderivation function using specific adapters.\n\n\nUser passwords are not really suitable to be used as keys in cryptographic\nalgorithms, since users normally choose keys they can write with a keyboard. These\npasswords use only 6 to 7 bits per character (or less). It is highly recommended\nalways to use a KDF function to transform a user's password in a cryptographic\nkey.\n\n\nThe output of the following key derivation functions is a binary string. If you\nneed to store the value in a database or a different persistent storage, we\nsuggest converting it to Base64 format, using the\n\nbase64_encode()\n function,\nor to hex format, using the\n\nbin2hex()\n function.\n\n\nPbkdf2 adapter\n\n\nPbkdf2\n is a KDF that applies a\npseudorandom function, such as a cryptographic hash, to the input password or\npassphrase along with a salt value and repeats the process many times to produce\na derived key, which can then be used as a cryptographic key in subsequent\noperations. The added computational work makes password cracking much more\ndifficult, and is known as \nkey\nstretching\n.\n\n\nIn the example below we demonstrate typical usage of the \nPbkdf2\n adapter.\n\n\nuse Zend\\Crypt\\Key\\Derivation\\Pbkdf2;\nuse Zend\\Math\\Rand;\n\n$pass = 'password';\n$salt = Rand::getBytes(32, true);\n$key  = Pbkdf2::calc('sha256', $pass, $salt, 10000, 32);\n\nprintf (\nOriginal password: %s\\n\n, $pass);\nprintf (\nDerived key (hex): %s\\n\n, bin2hex($key));\n\n\n\n\nThe \nPbkdf2\n adapter takes the password (\n$pass\n) and generates a binary key of\n32 bytes. The syntax is \ncalc($hash, $pass, $salt, $iterations, $length)\n where\n\n$hash\n is the name of the hash function to use, \n$pass\n is the password,\n\n$salt\n is a pseudo random value, \n$iterations\n is the number of iterations of\nthe algorithm, and \n$length\n is the size of the key to be generated. We use the\n\nRand::getBytes()\n function from the class \nZend\\Math\\Rand\n to generate a random\nstring of 32 bytes for the salt, using a strong generator (the \ntrue\n value\nmeans the usage of a cryptographically strong generator).\n\n\nThe number of iterations is a very important parameter for the security of the\nalgorithm; bigger values guarantee more security. There is no fixed value for\nthe parameter because the number of iterations depends on CPU power. You should\nalways choose a number of iterations that prevents brute force attacks.\n\n\nSaltedS2k adapter\n\n\nThe \nSaltedS2k\n algorithm uses a hash\nfunction and a salt to generate a key based on a user's password. This algorithm\ndoesn't use a parameter to specify the number of iterations, and for that reason\nit's considered less secure compared to Pbkdf2. We suggest using the SaltedS2k\nalgorithm only if you really need it (for instance, due to hardware\nlimitations).\n\n\nThe following demonstrates usage of the \nSaltedS2k\n adapter to generate a 32\nbyte key.\n\n\nuse Zend\\Crypt\\Key\\Derivation\\SaltedS2k;\nuse Zend\\Math\\Rand;\n\n$pass = 'password';\n$salt = Rand::getBytes(32, true);\n$key  = SaltedS2k::calc('sha256', $pass, $salt, 32);\n\nprintf (\nOriginal password: %s\\n\n, $pass);\nprintf (\nDerived key (hex): %s\\n\n, bin2hex($key));\n\n\n\n\nScrypt adapter\n\n\nThe \nscrypt\n algorithm uses the \nSalsa20/8\ncore\n algorithm and Pbkdf2-SHA256 to generate a\nkey based on a user's password. This algorithm has been designed to be more\nsecure against hardware brute-force attacks than alternative functions such as\n\nPbkdf2\n or\n\nbcrypt\n.\n\n\nThe scrypt algorithm is based on the idea of memory-hard algorithms and\nsequential memory-hard functions. A memory-hard algorithm is an algorithm which\nasymptotically uses almost as many memory locations as it uses\noperations\n1\n. A natural way to reduce the advantage\nprovided by an attacker\u2019s ability to construct highly parallel circuits is to\nincrease the size of a single key derivation circuit \u2014 if a circuit is twice as\nlarge, only half as many copies can be placed on a given area of silicon \u2014 while\nstill operating within the resources available to software implementations,\nincluding a powerful CPU and large amounts of RAM.\n\n\n\n\n\"From a test executed on modern (2009) hardware, if 5 seconds are spent\ncomputing a derived key, the cost of a hardware brute-force attack against\nscrypt is roughly 4000 times greater than the cost of a similar attack against\nbcrypt (to find the same password), and 20000 times greater than a similar\nattack against Pbkdf2.\"\n\n\n \nColin Percival\n (author of the scrypt algorithm)\n\n\n\n\nThis algorithm uses 4 parameters to generate a key of 32 bytes:\n\n\n\n\nsalt\n, a random string;\n\n\nN\n, the CPU cost;\n\n\nr\n, the memory cost;\n\n\np\n, the parallelization cost.\n\n\n\n\nFollowing is a usage example for the \nScrypt\n adapter:\n\n\nuse Zend\\Crypt\\Key\\Derivation\\Scrypt;\nuse Zend\\Math\\Rand;\n\n$pass = 'password';\n$salt = Rand::getBytes(32, true);\n$key  = Scrypt::calc($pass, $salt, 2048, 2, 1, 32);\n\nprintf (\nOriginal password: %s\\n\n, $pass);\nprintf (\nDerived key (hex): %s\\n\n, bin2hex($key));\n\n\n\n\n\n\nPerformance of the scrypt implementation\n\n\nThe aim of the scrypt algorithm is to generate a secure derived key that\nprevents brute force attacks.  Just like the other derivation functions, the\nmore time (and memory) spent executing the algorithm, the more secure the\nderived key will be. Unfortunately a pure PHP implementation of the scrypt\nalgorithm is very slow compared with the C implementation (this is always\ntrue, if you compare execution time of C with PHP). If you want use a faster\nscrypt algorithm, we suggest installing the PECL \nscrypt\nextension\n. The \nScrypt\n adapter we\nprovide is able to recognize if the PECL extension is loaded and will use it\ninstead of the pure PHP implementation.\n\n\n\n\nFootnotes\n\n\n\n\n1\n See Colin Percival's \nslides on scrypt from BSDCan'09\n.", 
            "title": "Key Derivation"
        }, 
        {
            "location": "/key-derivation/#key-derivation-function", 
            "text": "In cryptography, a key derivation function (or KDF) derives one or more secret\nkeys from a secret value such as a master key, or known information   such\nas a password or passphrase   using a pseudo-random function. For\ninstance, a KDF function can be used to generate encryption or authentication\nkeys from a user password.  Zend\\Crypt\\Key\\Derivation  implements a key\nderivation function using specific adapters.  User passwords are not really suitable to be used as keys in cryptographic\nalgorithms, since users normally choose keys they can write with a keyboard. These\npasswords use only 6 to 7 bits per character (or less). It is highly recommended\nalways to use a KDF function to transform a user's password in a cryptographic\nkey.  The output of the following key derivation functions is a binary string. If you\nneed to store the value in a database or a different persistent storage, we\nsuggest converting it to Base64 format, using the base64_encode()  function,\nor to hex format, using the bin2hex()  function.", 
            "title": "Key derivation function"
        }, 
        {
            "location": "/key-derivation/#pbkdf2-adapter", 
            "text": "Pbkdf2  is a KDF that applies a\npseudorandom function, such as a cryptographic hash, to the input password or\npassphrase along with a salt value and repeats the process many times to produce\na derived key, which can then be used as a cryptographic key in subsequent\noperations. The added computational work makes password cracking much more\ndifficult, and is known as  key\nstretching .  In the example below we demonstrate typical usage of the  Pbkdf2  adapter.  use Zend\\Crypt\\Key\\Derivation\\Pbkdf2;\nuse Zend\\Math\\Rand;\n\n$pass = 'password';\n$salt = Rand::getBytes(32, true);\n$key  = Pbkdf2::calc('sha256', $pass, $salt, 10000, 32);\n\nprintf ( Original password: %s\\n , $pass);\nprintf ( Derived key (hex): %s\\n , bin2hex($key));  The  Pbkdf2  adapter takes the password ( $pass ) and generates a binary key of\n32 bytes. The syntax is  calc($hash, $pass, $salt, $iterations, $length)  where $hash  is the name of the hash function to use,  $pass  is the password, $salt  is a pseudo random value,  $iterations  is the number of iterations of\nthe algorithm, and  $length  is the size of the key to be generated. We use the Rand::getBytes()  function from the class  Zend\\Math\\Rand  to generate a random\nstring of 32 bytes for the salt, using a strong generator (the  true  value\nmeans the usage of a cryptographically strong generator).  The number of iterations is a very important parameter for the security of the\nalgorithm; bigger values guarantee more security. There is no fixed value for\nthe parameter because the number of iterations depends on CPU power. You should\nalways choose a number of iterations that prevents brute force attacks.", 
            "title": "Pbkdf2 adapter"
        }, 
        {
            "location": "/key-derivation/#salteds2k-adapter", 
            "text": "The  SaltedS2k  algorithm uses a hash\nfunction and a salt to generate a key based on a user's password. This algorithm\ndoesn't use a parameter to specify the number of iterations, and for that reason\nit's considered less secure compared to Pbkdf2. We suggest using the SaltedS2k\nalgorithm only if you really need it (for instance, due to hardware\nlimitations).  The following demonstrates usage of the  SaltedS2k  adapter to generate a 32\nbyte key.  use Zend\\Crypt\\Key\\Derivation\\SaltedS2k;\nuse Zend\\Math\\Rand;\n\n$pass = 'password';\n$salt = Rand::getBytes(32, true);\n$key  = SaltedS2k::calc('sha256', $pass, $salt, 32);\n\nprintf ( Original password: %s\\n , $pass);\nprintf ( Derived key (hex): %s\\n , bin2hex($key));", 
            "title": "SaltedS2k adapter"
        }, 
        {
            "location": "/key-derivation/#scrypt-adapter", 
            "text": "The  scrypt  algorithm uses the  Salsa20/8\ncore  algorithm and Pbkdf2-SHA256 to generate a\nkey based on a user's password. This algorithm has been designed to be more\nsecure against hardware brute-force attacks than alternative functions such as Pbkdf2  or bcrypt .  The scrypt algorithm is based on the idea of memory-hard algorithms and\nsequential memory-hard functions. A memory-hard algorithm is an algorithm which\nasymptotically uses almost as many memory locations as it uses\noperations 1 . A natural way to reduce the advantage\nprovided by an attacker\u2019s ability to construct highly parallel circuits is to\nincrease the size of a single key derivation circuit \u2014 if a circuit is twice as\nlarge, only half as many copies can be placed on a given area of silicon \u2014 while\nstill operating within the resources available to software implementations,\nincluding a powerful CPU and large amounts of RAM.   \"From a test executed on modern (2009) hardware, if 5 seconds are spent\ncomputing a derived key, the cost of a hardware brute-force attack against\nscrypt is roughly 4000 times greater than the cost of a similar attack against\nbcrypt (to find the same password), and 20000 times greater than a similar\nattack against Pbkdf2.\"    Colin Percival  (author of the scrypt algorithm)   This algorithm uses 4 parameters to generate a key of 32 bytes:   salt , a random string;  N , the CPU cost;  r , the memory cost;  p , the parallelization cost.   Following is a usage example for the  Scrypt  adapter:  use Zend\\Crypt\\Key\\Derivation\\Scrypt;\nuse Zend\\Math\\Rand;\n\n$pass = 'password';\n$salt = Rand::getBytes(32, true);\n$key  = Scrypt::calc($pass, $salt, 2048, 2, 1, 32);\n\nprintf ( Original password: %s\\n , $pass);\nprintf ( Derived key (hex): %s\\n , bin2hex($key));", 
            "title": "Scrypt adapter"
        }, 
        {
            "location": "/key-derivation/#performance-of-the-scrypt-implementation", 
            "text": "The aim of the scrypt algorithm is to generate a secure derived key that\nprevents brute force attacks.  Just like the other derivation functions, the\nmore time (and memory) spent executing the algorithm, the more secure the\nderived key will be. Unfortunately a pure PHP implementation of the scrypt\nalgorithm is very slow compared with the C implementation (this is always\ntrue, if you compare execution time of C with PHP). If you want use a faster\nscrypt algorithm, we suggest installing the PECL  scrypt\nextension . The  Scrypt  adapter we\nprovide is able to recognize if the PECL extension is loaded and will use it\ninstead of the pure PHP implementation.", 
            "title": "Performance of the scrypt implementation"
        }, 
        {
            "location": "/key-derivation/#footnotes", 
            "text": "1  See Colin Percival's  slides on scrypt from BSDCan'09 .", 
            "title": "Footnotes"
        }, 
        {
            "location": "/password/", 
            "text": "Password\n\n\nIn the \nZend\\Crypt\\Password\n namespace you will find a number of password\nformats supported by the zend-crypt component. These currently include:\n\n\n\n\nbcrypt\n\n\nApache (htpasswd)\n\n\n\n\nIf you need to choose a password format to store a user\u2019s password, we suggest\nusing the bcrypt algorithm, as it is considered secure against brute forcing\nattacks (see details below).\n\n\nBcrypt\n\n\nThe \nbcrypt\n algorithm is a hashing algorithm\nthat is widely used and recommended by the security community to store user\npasswords in a secure way.\n\n\nClassic hashing mechanisms like MD5 or SHA, with or without a salt value, are\nnot considered secure anymore (\nread this post to understand\nwhy\n).\n\n\nThe security of bcrypt is related to the speed of the algorithm. Bcrypt is very\nslow, and can take up to a second to generate a hash value. That means a brute\nforce attack is impossible to execute, due to the amount of time that required.\n\n\nBcrypt uses a \ncost\n parameter that specify the number of cycles to use in the\nalgorithm. Increasing this number the algorithm will spend more time to generate\nthe hash output. The cost parameter is represented by an integer value between 4\nto 31. The default cost value of \nZend\\Crypt\\Password\\Bcrypt\n is 10, requiring\naround 0.07s using a CPU Intel i5 at 3.3Ghz (the cost parameter is a relative\nvalue according to the speed of the CPU used). Starting with version 2.3.0, we\nchanged the default value of the cost parameter from 14 to 10, in an effort to\nreduce denial-of-service attacks due to too high computational time\nrequirements. (Read this article on \naggressive password stretching\n\nfor more information).\n\n\nIf you want to change the cost parameter of the bcrypt algorithm, you can use\nthe \nsetCost()\n method. Please note, if you change the cost parameter, the\nresulting hash will be different. However, This will not affect the verification\nprocess of the algorithm, therefore not breaking the password hashes you already\nhave stored; Bcrypt reads the cost parameter from the hash value during password\nauthentication. All of the parts needed to verify the hash are present in the\nhash itself,, separated with \n$\n\u2019s; first the algorithm, then the cost, the\nsalt, and then finally the hash.\n\n\nThe example below demonstrates using the bcrypt algorithm to store a user\u2019s password:\n\n\nuse Zend\\Crypt\\Password\\Bcrypt;\n\n$bcrypt = new Bcrypt();\n$securePass = $bcrypt-\ncreate('user password');\n\n\n\n\nThe output of the \ncreate()\n method is the hash of the password. This value can\nthen be stored in a repository like a database (the output is a string of 60\nbytes).\n\n\n\n\nBcrypt truncates input \n 72 bytes\n\n\nThe input string of the bcrypt algorithm is limited to 72 bytes. If you use a\nstring with a length more than this limit, bcrypt will consider only the first\n72 bytes. If you need to use a longer string, you should pre-hash it.\nWe provide the class \nZend\\Crypt\\Password\\BcryptSha\n for performing\npassword pre-hashing of hash input \n 72 bytes.\n\n\n\n\nTo verify if a given password is valid against a bcrypt value you can use the\n\nverify()\n method. The example below demonstrates verification:\n\n\nuse Zend\\Crypt\\Password\\Bcrypt;\n\n$bcrypt = new Bcrypt();\n$securePass = 'the stored bcrypt value';\n$password = 'the password to check';\n\nif ($bcrypt-\nverify($password, $securePass)) {\n    echo \nThe password is correct! \\n\n;\n} else {\n    echo \nThe password is NOT correct.\\n\n;\n}\n\n\n\n\nBcrypt also uses a salt value to improve the randomness of the algorithm.\nBy default, \nZend\\Crypt\\Password\\Bcrypt\n generates a random salt for\neach hash. If you want to specify a preselected salt you can use the \nsetSalt()\n\nmethod.\n\n\nWe also provide a \ngetSalt()\n method to retrieve the salt specified by the user.\nThe salt and the cost parameter can be also specified during the constructor of\nthe class, as demonstrated below:\n\n\nuse Zend\\Crypt\\Password\\Bcrypt;\n\n$bcrypt = new Bcrypt([\n    'salt' =\n 'random value',\n    'cost' =\n 11\n]);\n\n\n\n\n\n\nVersion 3.0\n\n\nStarting with version 3.0, we now use the \npassword_hash()\n\nand `\npassword_verify()\n functions introduced\nin PHP 5.5 to generate bcrypt hash values. We provide backwards\ncompatibility tests to ensure that any hashes generated with version 2\nreleases can still be validated under version 3.\n\n\n\n\nApache\n\n\nZend\\Crypt\\Password\\Apache\n supports all the password formats used by\n\nApache\n\n(htpasswd). These formats include:\n\n\n\n\nCRYPT, which uses the traditional Unix crypt(3) function with a\n  randomly-generated 32-bit salt (only 12 bits used) and the first 8 characters\n  of the password;\n\n\nSHA1, \u201c{SHA}\u201d + Base64-encoded SHA-1 digest of the password;\n\n\nMD5, \u201c$apr1$\u201d + the result of an Apache-specific algorithm using an iterated\n  (1,000 times) MD5 digest of various combinations of a random 32-bit salt and\n  the password.\n\n\nDigest, the MD5 hash of the string \nuser:realm:password\n as a 32-character\n  string of hexadecimal digits. \nrealm\n is the Authorization Realm argument to\n  the AuthName directive in \nhttpd.conf\n.\n\n\n\n\nIn order to specify the format of the Apache\u2019s password, use the \nsetFormat()\n\nmethod. An example with all the formats usage is demostrated below:\n\n\nuse Zend\\Crypt\\Password\\Apache;\n\n$apache = new Apache();\n\n$apache-\nsetFormat('crypt');\nprintf (\nCRYPT output: %s\\n\n, $apache-\ncreate('password'));\n\n$apache-\nsetFormat('sha1');\nprintf (\nSHA1 output: %s\\n\n, $apache-\ncreate('password'));\n\n$apache-\nsetFormat('md5');\nprintf (\nMD5 output: %s\\n\n, $apache-\ncreate('password'));\n\n$apache-\nsetFormat('digest');\n$apache-\nsetUserName('enrico');\n$apache-\nsetAuthName('test');\nprintf (\nDigest output: %s\\n\n, $apache-\ncreate('password'));\n\n\n\n\nYou can also specify the format of the password during the constructor of the class:\n\n\nuse Zend\\Crypt\\Password\\Apache;\n\n$apache = new Apache([\n    'format' =\n 'md5'\n]);\n\n\n\n\nOther possible parameters to pass in the constructor are \nusername\n and \nauthname\n,\nfor the digest format.", 
            "title": "Passwords"
        }, 
        {
            "location": "/password/#password", 
            "text": "In the  Zend\\Crypt\\Password  namespace you will find a number of password\nformats supported by the zend-crypt component. These currently include:   bcrypt  Apache (htpasswd)   If you need to choose a password format to store a user\u2019s password, we suggest\nusing the bcrypt algorithm, as it is considered secure against brute forcing\nattacks (see details below).", 
            "title": "Password"
        }, 
        {
            "location": "/password/#bcrypt", 
            "text": "The  bcrypt  algorithm is a hashing algorithm\nthat is widely used and recommended by the security community to store user\npasswords in a secure way.  Classic hashing mechanisms like MD5 or SHA, with or without a salt value, are\nnot considered secure anymore ( read this post to understand\nwhy ).  The security of bcrypt is related to the speed of the algorithm. Bcrypt is very\nslow, and can take up to a second to generate a hash value. That means a brute\nforce attack is impossible to execute, due to the amount of time that required.  Bcrypt uses a  cost  parameter that specify the number of cycles to use in the\nalgorithm. Increasing this number the algorithm will spend more time to generate\nthe hash output. The cost parameter is represented by an integer value between 4\nto 31. The default cost value of  Zend\\Crypt\\Password\\Bcrypt  is 10, requiring\naround 0.07s using a CPU Intel i5 at 3.3Ghz (the cost parameter is a relative\nvalue according to the speed of the CPU used). Starting with version 2.3.0, we\nchanged the default value of the cost parameter from 14 to 10, in an effort to\nreduce denial-of-service attacks due to too high computational time\nrequirements. (Read this article on  aggressive password stretching \nfor more information).  If you want to change the cost parameter of the bcrypt algorithm, you can use\nthe  setCost()  method. Please note, if you change the cost parameter, the\nresulting hash will be different. However, This will not affect the verification\nprocess of the algorithm, therefore not breaking the password hashes you already\nhave stored; Bcrypt reads the cost parameter from the hash value during password\nauthentication. All of the parts needed to verify the hash are present in the\nhash itself,, separated with  $ \u2019s; first the algorithm, then the cost, the\nsalt, and then finally the hash.  The example below demonstrates using the bcrypt algorithm to store a user\u2019s password:  use Zend\\Crypt\\Password\\Bcrypt;\n\n$bcrypt = new Bcrypt();\n$securePass = $bcrypt- create('user password');  The output of the  create()  method is the hash of the password. This value can\nthen be stored in a repository like a database (the output is a string of 60\nbytes).", 
            "title": "Bcrypt"
        }, 
        {
            "location": "/password/#bcrypt-truncates-input-72-bytes", 
            "text": "The input string of the bcrypt algorithm is limited to 72 bytes. If you use a\nstring with a length more than this limit, bcrypt will consider only the first\n72 bytes. If you need to use a longer string, you should pre-hash it.\nWe provide the class  Zend\\Crypt\\Password\\BcryptSha  for performing\npassword pre-hashing of hash input   72 bytes.   To verify if a given password is valid against a bcrypt value you can use the verify()  method. The example below demonstrates verification:  use Zend\\Crypt\\Password\\Bcrypt;\n\n$bcrypt = new Bcrypt();\n$securePass = 'the stored bcrypt value';\n$password = 'the password to check';\n\nif ($bcrypt- verify($password, $securePass)) {\n    echo  The password is correct! \\n ;\n} else {\n    echo  The password is NOT correct.\\n ;\n}  Bcrypt also uses a salt value to improve the randomness of the algorithm.\nBy default,  Zend\\Crypt\\Password\\Bcrypt  generates a random salt for\neach hash. If you want to specify a preselected salt you can use the  setSalt() \nmethod.  We also provide a  getSalt()  method to retrieve the salt specified by the user.\nThe salt and the cost parameter can be also specified during the constructor of\nthe class, as demonstrated below:  use Zend\\Crypt\\Password\\Bcrypt;\n\n$bcrypt = new Bcrypt([\n    'salt' =  'random value',\n    'cost' =  11\n]);", 
            "title": "Bcrypt truncates input &gt; 72 bytes"
        }, 
        {
            "location": "/password/#version-30", 
            "text": "Starting with version 3.0, we now use the  password_hash() \nand ` password_verify()  functions introduced\nin PHP 5.5 to generate bcrypt hash values. We provide backwards\ncompatibility tests to ensure that any hashes generated with version 2\nreleases can still be validated under version 3.", 
            "title": "Version 3.0"
        }, 
        {
            "location": "/password/#apache", 
            "text": "Zend\\Crypt\\Password\\Apache  supports all the password formats used by Apache \n(htpasswd). These formats include:   CRYPT, which uses the traditional Unix crypt(3) function with a\n  randomly-generated 32-bit salt (only 12 bits used) and the first 8 characters\n  of the password;  SHA1, \u201c{SHA}\u201d + Base64-encoded SHA-1 digest of the password;  MD5, \u201c$apr1$\u201d + the result of an Apache-specific algorithm using an iterated\n  (1,000 times) MD5 digest of various combinations of a random 32-bit salt and\n  the password.  Digest, the MD5 hash of the string  user:realm:password  as a 32-character\n  string of hexadecimal digits.  realm  is the Authorization Realm argument to\n  the AuthName directive in  httpd.conf .   In order to specify the format of the Apache\u2019s password, use the  setFormat() \nmethod. An example with all the formats usage is demostrated below:  use Zend\\Crypt\\Password\\Apache;\n\n$apache = new Apache();\n\n$apache- setFormat('crypt');\nprintf ( CRYPT output: %s\\n , $apache- create('password'));\n\n$apache- setFormat('sha1');\nprintf ( SHA1 output: %s\\n , $apache- create('password'));\n\n$apache- setFormat('md5');\nprintf ( MD5 output: %s\\n , $apache- create('password'));\n\n$apache- setFormat('digest');\n$apache- setUserName('enrico');\n$apache- setAuthName('test');\nprintf ( Digest output: %s\\n , $apache- create('password'));  You can also specify the format of the password during the constructor of the class:  use Zend\\Crypt\\Password\\Apache;\n\n$apache = new Apache([\n    'format' =  'md5'\n]);  Other possible parameters to pass in the constructor are  username  and  authname ,\nfor the digest format.", 
            "title": "Apache"
        }, 
        {
            "location": "/public-key/", 
            "text": "Public key cryptography\n\n\nPublic-key cryptography refers to a cryptographic system requiring two separate\nkeys, one of which is secret and one of which is public. Although different, the\ntwo parts of the key pair are mathematically linked. One key locks or encrypts\nthe plaintext, and the other unlocks or decrypts the cyphertext. Neither key can\nperform both functions. One of these keys is published or public, while the\nother is kept private.\n\n\nIn zend-crypt, we implement two public key algorithms:\n\n\n\n\nDiffie-Hellman\n\n  key exchange, and\n\n\nRSA\n.\n\n\n\n\nDiffie-Hellman\n\n\nThe Diffie-Hellman algorithm is a specific method of exchanging cryptographic\nkeys. It is one of the earliest practical examples of key exchange implemented\nwithin the field of cryptography. The Diffie\u2013Hellman key exchange method allows\ntwo parties that have no prior knowledge of each other to jointly establish a\nshared secret key over an insecure communications channel. This key can then be\nused to encrypt subsequent communications using a symmetric key cipher.\n\n\nThe diagram of operation of the Diffie-Hellman algorithm can be defined by the\nfollowing picture (taken from the \nDiffie-Hellman\n\nWikipedia page):\n\n\n\n\nThe schema's colors represent the parameters of the algorithm.\n\n\nBelow is an example demonstrating usage of \nZend\\Crypt\\PublicKey\\DiffieHellman\n:\n\n\nuse Zend\\Crypt\\PublicKey\\DiffieHellman;\n\n$aliceOptions = [\n    'prime' =\n '155172898181473697471232257763715539915724801966915404479707795314057629378541917580651227'\n        . '423698188993727816152646631438561595825688188889951272158842675419950341258706556549803580'\n        . '104870537681476726513255747040765857479291291572334510643245094715007229621094194349783925'\n        . '984760375594985848253359305585439638443',\n    'generator'=\n '2',\n    'private'  =\n '992093140665725952364085695919679885571412495614942674862518080355353963322786201435363176'\n        . '813127128916726230726309951803243888416814918577455156967890911274095150092503589658166661'\n        . '463420498381785213791321533481399080168191962194483101070726325157493390557981225386151351'\n        . '04828702523796951800575031871051678091',\n];\n\n$bobOptions   = [\n    'prime'    =\n $aliceOptions['prime'],\n    'generator'=\n '2',\n    'private'  =\n '334117357926395586257336357178925636125481806504021611510774783148414637079488997861035889'\n        . '123256347304105519467727528801778689728169635518217403867000760342134081539246925625431179'\n        . '634647331566005454845108330724270034742070646507148310833044977371603820970833568760781462'\n        . '31616972608703322302585471319261275664',\n);\n\n$alice = new DiffieHellman(\n    $aliceOptions['prime'],\n    $aliceOptions['generator'],\n    $aliceOptions['private']\n);\n$bob = new DiffieHellman(\n    $bobOptions['prime'],\n    $bobOptions['generator'],\n    $bobOptions['private']\n);\n\n$alice-\ngenerateKeys();\n$bob-\ngenerateKeys();\n\n$aliceSecretKey = $alice-\ncomputeSecretKey(\n    $bob-\ngetPublicKey(DiffieHellman::FORMAT_BINARY),\n    DiffieHellman::FORMAT_BINARY,\n    DiffieHellman::FORMAT_BINARY\n);\n\n$bobSecretKey = $bob-\ncomputeSecretKey(\n    $alice-\ngetPublicKey(DiffieHellman::FORMAT_BINARY),\n    DiffieHellman::FORMAT_BINARY,\n    DiffieHellman::FORMAT_BINARY\n);\n\nif ($aliceSecretKey !== $bobSecretKey) {\n    echo \nERROR!\\n\n;\n} else {\n    printf(\nThe secret key is: %s\\n\n, base64_encode($aliceSecretKey));\n}\n\n\n\n\nThe parameters of the Diffie-Hellman class are:\n\n\n\n\na prime number (p),\n\n\na generator (g) that is a primitive root mod p, and\n\n\na private integer number.\n\n\n\n\nThe security of the Diffie-Hellman exchange algorithm is related to the choice\nof these parameters. To know how to choose secure numbers you can read the\n\nRFC 3526\n document.\n\n\n\n\nOpenssl\n\n\nThe \nZend\\Crypt\\PublicKey\\DiffieHellman\n class by default uses the\n\nOpenSSL\n extension to generate the\nparameters. If you don't want to use the OpenSSL library, call\n\nDiffieHelmman::useOpensslExtension(false)\n.\n\n\n\n\nRSA\n\n\nRSA is an algorithm for public-key cryptography that is based on the presumed\ndifficulty of factoring large integers, known as the \nfactoring\nproblem\n. A user of RSA creates\nand then publishes the product of two large prime numbers, along with an\nauxiliary value, as their public key. The prime factors must be kept secret.\nAnyone can use the public key to encrypt a message, but with currently published\nmethods, if the public key is large enough, only someone with knowledge of the\nprime factors can feasibly decode the message. Whether breaking RSA encryption\nis as hard as factoring is an open question.\n\n\nThe RSA algorithm can be used to encrypt/decrypt messages, and also to provide\nauthenticity and integrity by generating a digital signature of a message.\n\n\nSuppose that Alice wants to send an encrypted message to Bob. Alice must use the\npublic key of Bob to encrypt the message. Bob can decrypt the message using his\nprivate key. Because Bob is the only one that can access his private key,\nhe is the only one that can decrypt the message. If Alice wants to provide\nauthenticity and integrity of a message to Bob she can use her private key to\nsign the message. Bob can check the correctness of the digital signature using\nthe public key of Alice. Alice can provide encryption, authenticity, and\nintegrity of a message to Bob using the previous schemas in sequence, applying\nthe encryption first and the digital signature after.\n\n\nBelow are examples of usage of the \nZend\\Crypt\\PublicKey\\Rsa\n class in order to:\n\n\n\n\ngenerate a public key and a private key;\n\n\nencrypt/decrypt a string;\n\n\ngenerate a digital signature of a file.\n\n\n\n\nGenerate a public key and a private key\n\n\nIn order to generate a public and private key, use the following code:\n\n\nuse Zend\\Crypt\\PublicKey\\RsaOptions;\n\n$rsaOptions = new RsaOptions([\n    'pass_phrase' =\n 'test'\n[);\n\n$rsaOptions-\ngenerateKeys([\n    'private_key_bits' =\n 2048,\n]);\n\nfile_put_contents('private_key.pem', $rsaOptions-\ngetPrivateKey());\nfile_put_contents('public_key.pub', $rsaOptions-\ngetPublicKey());\n\n\n\n\nThis example generates a 2048-bit public and private key, storing the keys in two separate files,\n\nprivate_key.pem\n for the private key and \npublic_key.pub\n for the public key. You can also\ngenerate the public and private key using OpenSSL from the command line (Unix style syntax):\n\n\n$ ssh-keygen -t rsa\n\n\n\n\nEncrypt and decrypt a string\n\n\nBelow is an example demonstrating encryption and decryption of a string using\nthe RSA algorithm. You can encrypt only small strings. The maximum size of\nencryption is given by the length of the public/private key - 88 bits. For\ninstance, if we use a size of 2048 bit you can encrypt a string with a maximum\nsize of 1960 bit (245 characters). This limitation is related to the OpenSSL\nimplementation for a security reason related to the nature of the RSA algorithm.\n\n\nThe normal application of public key encryption algorithm is to store a key or a\nhash of the data you want to encrypt or sign. A hash is typically 128-256 bits\n(the PHP \nsha1()\n function returns a 160 bit hash). An AES encryption key is 128\nto 256 bits. Either will comfortably fit inside a single RSA encryption.\n\n\nuse Zend\\Crypt\\PublicKey\\Rsa;\n\n$rsa = Rsa::factory([\n    'public_key'    =\n 'public_key.pub',\n    'private_key'   =\n 'private_key.pem',\n    'pass_phrase'   =\n 'test',\n    'binary_output' =\n false,\n]);\n\n$text = 'This is the message to encrypt';\n\n$encrypt = $rsa-\nencrypt($text);\nprintf(\nEncrypted message:\\n%s\\n\n, $encrypt);\n\n$decrypt = $rsa-\ndecrypt($encrypt);\n\nif ($text !== $decrypt) {\n    echo \nERROR\\n\n;\n} else {\n    echo \nEncryption and decryption performed successfully!\\n\n;\n}\n\n\n\n\nGenerate a digital signature of a file\n\n\nBelow is an example demonstrating generation of a digital file signature.\n\n\nuse Zend\\Crypt\\PublicKey\\Rsa;\n\n$rsa = Rsa::factory([\n    'private_key'   =\n 'path/to/private_key',\n    'pass_phrase'   =\n 'passphrase of the private key',\n    'binary_output' =\n false,\n]);\n\n$file = file_get_contents('path/file/to/sign');\n\n$signature = $rsa-\nsign($file, $rsa-\ngetOptions()-\ngetPrivateKey());\n$verify    = $rsa-\nverify($file, $signature, $rsa-\ngetOptions()-\ngetPublicKey());\n\nif ($verify) {\n    echo \nThe signature is OK\\n\n;\n    file_put_contents($filename . '.sig', $signature);\n    echo \nSignature save in $filename.sig\\n\n;\n} else {\n     echo \nThe signature is not valid!\\n\n;\n}\n\n\n\n\nIn this example, we used the Base64 format to encode the digital signature of the file\n(\nbinary_output\n is false).\n\n\n\n\nOpenssl\n\n\nThe implementation of the \nZend\\Crypt\\PublicKey\\Rsa\n algorithm uses PHP's OpenSSL extension.", 
            "title": "Public Key Cryptography"
        }, 
        {
            "location": "/public-key/#public-key-cryptography", 
            "text": "Public-key cryptography refers to a cryptographic system requiring two separate\nkeys, one of which is secret and one of which is public. Although different, the\ntwo parts of the key pair are mathematically linked. One key locks or encrypts\nthe plaintext, and the other unlocks or decrypts the cyphertext. Neither key can\nperform both functions. One of these keys is published or public, while the\nother is kept private.  In zend-crypt, we implement two public key algorithms:   Diffie-Hellman \n  key exchange, and  RSA .", 
            "title": "Public key cryptography"
        }, 
        {
            "location": "/public-key/#diffie-hellman", 
            "text": "The Diffie-Hellman algorithm is a specific method of exchanging cryptographic\nkeys. It is one of the earliest practical examples of key exchange implemented\nwithin the field of cryptography. The Diffie\u2013Hellman key exchange method allows\ntwo parties that have no prior knowledge of each other to jointly establish a\nshared secret key over an insecure communications channel. This key can then be\nused to encrypt subsequent communications using a symmetric key cipher.  The diagram of operation of the Diffie-Hellman algorithm can be defined by the\nfollowing picture (taken from the  Diffie-Hellman \nWikipedia page):   The schema's colors represent the parameters of the algorithm.  Below is an example demonstrating usage of  Zend\\Crypt\\PublicKey\\DiffieHellman :  use Zend\\Crypt\\PublicKey\\DiffieHellman;\n\n$aliceOptions = [\n    'prime' =  '155172898181473697471232257763715539915724801966915404479707795314057629378541917580651227'\n        . '423698188993727816152646631438561595825688188889951272158842675419950341258706556549803580'\n        . '104870537681476726513255747040765857479291291572334510643245094715007229621094194349783925'\n        . '984760375594985848253359305585439638443',\n    'generator'=  '2',\n    'private'  =  '992093140665725952364085695919679885571412495614942674862518080355353963322786201435363176'\n        . '813127128916726230726309951803243888416814918577455156967890911274095150092503589658166661'\n        . '463420498381785213791321533481399080168191962194483101070726325157493390557981225386151351'\n        . '04828702523796951800575031871051678091',\n];\n\n$bobOptions   = [\n    'prime'    =  $aliceOptions['prime'],\n    'generator'=  '2',\n    'private'  =  '334117357926395586257336357178925636125481806504021611510774783148414637079488997861035889'\n        . '123256347304105519467727528801778689728169635518217403867000760342134081539246925625431179'\n        . '634647331566005454845108330724270034742070646507148310833044977371603820970833568760781462'\n        . '31616972608703322302585471319261275664',\n);\n\n$alice = new DiffieHellman(\n    $aliceOptions['prime'],\n    $aliceOptions['generator'],\n    $aliceOptions['private']\n);\n$bob = new DiffieHellman(\n    $bobOptions['prime'],\n    $bobOptions['generator'],\n    $bobOptions['private']\n);\n\n$alice- generateKeys();\n$bob- generateKeys();\n\n$aliceSecretKey = $alice- computeSecretKey(\n    $bob- getPublicKey(DiffieHellman::FORMAT_BINARY),\n    DiffieHellman::FORMAT_BINARY,\n    DiffieHellman::FORMAT_BINARY\n);\n\n$bobSecretKey = $bob- computeSecretKey(\n    $alice- getPublicKey(DiffieHellman::FORMAT_BINARY),\n    DiffieHellman::FORMAT_BINARY,\n    DiffieHellman::FORMAT_BINARY\n);\n\nif ($aliceSecretKey !== $bobSecretKey) {\n    echo  ERROR!\\n ;\n} else {\n    printf( The secret key is: %s\\n , base64_encode($aliceSecretKey));\n}  The parameters of the Diffie-Hellman class are:   a prime number (p),  a generator (g) that is a primitive root mod p, and  a private integer number.   The security of the Diffie-Hellman exchange algorithm is related to the choice\nof these parameters. To know how to choose secure numbers you can read the RFC 3526  document.", 
            "title": "Diffie-Hellman"
        }, 
        {
            "location": "/public-key/#openssl", 
            "text": "The  Zend\\Crypt\\PublicKey\\DiffieHellman  class by default uses the OpenSSL  extension to generate the\nparameters. If you don't want to use the OpenSSL library, call DiffieHelmman::useOpensslExtension(false) .", 
            "title": "Openssl"
        }, 
        {
            "location": "/public-key/#rsa", 
            "text": "RSA is an algorithm for public-key cryptography that is based on the presumed\ndifficulty of factoring large integers, known as the  factoring\nproblem . A user of RSA creates\nand then publishes the product of two large prime numbers, along with an\nauxiliary value, as their public key. The prime factors must be kept secret.\nAnyone can use the public key to encrypt a message, but with currently published\nmethods, if the public key is large enough, only someone with knowledge of the\nprime factors can feasibly decode the message. Whether breaking RSA encryption\nis as hard as factoring is an open question.  The RSA algorithm can be used to encrypt/decrypt messages, and also to provide\nauthenticity and integrity by generating a digital signature of a message.  Suppose that Alice wants to send an encrypted message to Bob. Alice must use the\npublic key of Bob to encrypt the message. Bob can decrypt the message using his\nprivate key. Because Bob is the only one that can access his private key,\nhe is the only one that can decrypt the message. If Alice wants to provide\nauthenticity and integrity of a message to Bob she can use her private key to\nsign the message. Bob can check the correctness of the digital signature using\nthe public key of Alice. Alice can provide encryption, authenticity, and\nintegrity of a message to Bob using the previous schemas in sequence, applying\nthe encryption first and the digital signature after.  Below are examples of usage of the  Zend\\Crypt\\PublicKey\\Rsa  class in order to:   generate a public key and a private key;  encrypt/decrypt a string;  generate a digital signature of a file.", 
            "title": "RSA"
        }, 
        {
            "location": "/public-key/#generate-a-public-key-and-a-private-key", 
            "text": "In order to generate a public and private key, use the following code:  use Zend\\Crypt\\PublicKey\\RsaOptions;\n\n$rsaOptions = new RsaOptions([\n    'pass_phrase' =  'test'\n[);\n\n$rsaOptions- generateKeys([\n    'private_key_bits' =  2048,\n]);\n\nfile_put_contents('private_key.pem', $rsaOptions- getPrivateKey());\nfile_put_contents('public_key.pub', $rsaOptions- getPublicKey());  This example generates a 2048-bit public and private key, storing the keys in two separate files, private_key.pem  for the private key and  public_key.pub  for the public key. You can also\ngenerate the public and private key using OpenSSL from the command line (Unix style syntax):  $ ssh-keygen -t rsa", 
            "title": "Generate a public key and a private key"
        }, 
        {
            "location": "/public-key/#encrypt-and-decrypt-a-string", 
            "text": "Below is an example demonstrating encryption and decryption of a string using\nthe RSA algorithm. You can encrypt only small strings. The maximum size of\nencryption is given by the length of the public/private key - 88 bits. For\ninstance, if we use a size of 2048 bit you can encrypt a string with a maximum\nsize of 1960 bit (245 characters). This limitation is related to the OpenSSL\nimplementation for a security reason related to the nature of the RSA algorithm.  The normal application of public key encryption algorithm is to store a key or a\nhash of the data you want to encrypt or sign. A hash is typically 128-256 bits\n(the PHP  sha1()  function returns a 160 bit hash). An AES encryption key is 128\nto 256 bits. Either will comfortably fit inside a single RSA encryption.  use Zend\\Crypt\\PublicKey\\Rsa;\n\n$rsa = Rsa::factory([\n    'public_key'    =  'public_key.pub',\n    'private_key'   =  'private_key.pem',\n    'pass_phrase'   =  'test',\n    'binary_output' =  false,\n]);\n\n$text = 'This is the message to encrypt';\n\n$encrypt = $rsa- encrypt($text);\nprintf( Encrypted message:\\n%s\\n , $encrypt);\n\n$decrypt = $rsa- decrypt($encrypt);\n\nif ($text !== $decrypt) {\n    echo  ERROR\\n ;\n} else {\n    echo  Encryption and decryption performed successfully!\\n ;\n}", 
            "title": "Encrypt and decrypt a string"
        }, 
        {
            "location": "/public-key/#generate-a-digital-signature-of-a-file", 
            "text": "Below is an example demonstrating generation of a digital file signature.  use Zend\\Crypt\\PublicKey\\Rsa;\n\n$rsa = Rsa::factory([\n    'private_key'   =  'path/to/private_key',\n    'pass_phrase'   =  'passphrase of the private key',\n    'binary_output' =  false,\n]);\n\n$file = file_get_contents('path/file/to/sign');\n\n$signature = $rsa- sign($file, $rsa- getOptions()- getPrivateKey());\n$verify    = $rsa- verify($file, $signature, $rsa- getOptions()- getPublicKey());\n\nif ($verify) {\n    echo  The signature is OK\\n ;\n    file_put_contents($filename . '.sig', $signature);\n    echo  Signature save in $filename.sig\\n ;\n} else {\n     echo  The signature is not valid!\\n ;\n}  In this example, we used the Base64 format to encode the digital signature of the file\n( binary_output  is false).", 
            "title": "Generate a digital signature of a file"
        }, 
        {
            "location": "/public-key/#openssl_1", 
            "text": "The implementation of the  Zend\\Crypt\\PublicKey\\Rsa  algorithm uses PHP's OpenSSL extension.", 
            "title": "Openssl"
        }
    ]
}